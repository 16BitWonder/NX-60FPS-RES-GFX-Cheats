import binascii
import os
import struct
import sys
import array

HEAD_MAGIC_SIZE = 5
IPS_HEAD_MAGIC = bytearray("PATCH", 'ascii')
IPS32_HEAD_MAGIC = bytearray("IPS32", 'ascii')

IPS_ADDRESS_SIZE = 3
IPS32_ADDRESS_SIZE = 4
IPS_FOOT_MAGIC = bytearray("EOF", 'ascii')
IPS32_FOOT_MAGIC = bytearray("EEOF", 'ascii')

IPS_PATCH_LEN_STRUCT = struct.Struct('>H')

NSO_HEADER_LEN = 0x100

CHEAT_EXT = ".txt"
CHEAT_ENCODING = "ascii"
CHEAT_TYPE = "04000000" # A cheat for just writing a static value to a main address

CHEAT_HEADER = f"// auto generated by ips2cheat\n\n"
PATCH_TEXT_ADDRESS_STRUCT = struct.Struct('>I')

def swap_endianness(hex_bytes: bytes):
    hex_str = hex_bytes.hex()
    hex_str_array = []
    for i in range(0, len(hex_str), 4):
        hex_str_array.append(hex_str[i:i+4])
    hex_str_array.reverse()
    hex_str = "".join(hex_str_array)
    return binascii.unhexlify(hex_str)

def ips2cheat(ips_path, cheat_name, out_cheat_path):
    ips_file = open(ips_path, 'rb')
    cur_head_magic = ips_file.read(HEAD_MAGIC_SIZE)
    if cur_head_magic == IPS_HEAD_MAGIC:
        cur_address_size = IPS_ADDRESS_SIZE
        cur_foot_magic = IPS_FOOT_MAGIC
    elif cur_head_magic == IPS32_HEAD_MAGIC:
        cur_address_size = IPS32_ADDRESS_SIZE
        cur_foot_magic = IPS32_FOOT_MAGIC
    else:
        print("Not an ips file")
        return -1

    ips_name = os.path.basename(ips_path)
    ips_name_no_ext = os.path.splitext(ips_name)[0]
    
    if out_cheat_path:
        out_cheat_file = open(out_cheat_path, 'wb+')
    else:
        out_cheat_file = open(ips_name_no_ext[:16] + CHEAT_EXT, 'wb+')
    print(f"Writing to {out_cheat_file.name}")
    out_cheat_file.write(CHEAT_HEADER.encode(CHEAT_ENCODING))
    out_cheat_file.write(f"[{cheat_name}]\n".encode(CHEAT_ENCODING))

    while True:
        cur_address_bytes = ips_file.read(cur_address_size)
        if cur_address_bytes == cur_foot_magic:
            break

        cur_address = 0
        for exponent in range(cur_address_size):
            cur_address += cur_address_bytes[cur_address_size -
                                             1 - exponent] << (exponent * 8)
        cur_address -= NSO_HEADER_LEN

        cur_len = IPS_PATCH_LEN_STRUCT.unpack(
            ips_file.read(IPS_PATCH_LEN_STRUCT.size))[0]
        cur_value = ips_file.read(cur_len)

        out_cheat_file.write(CHEAT_TYPE.encode(CHEAT_ENCODING))
        out_cheat_file.write(" ".encode(CHEAT_ENCODING))
        out_cheat_file.write(binascii.b2a_hex(
            PATCH_TEXT_ADDRESS_STRUCT.pack(cur_address)).upper())
        out_cheat_file.write(" ".encode(CHEAT_ENCODING))
        out_cheat_file.write(swap_endianness(
            binascii.b2a_hex(cur_value).upper()))
        out_cheat_file.write("\n".encode(CHEAT_ENCODING))

    out_cheat_file.close()


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: ips2cheat.py <ips_path> [cheat_name] [cheat_file_path]")
    else:
        cheat_name = "Cheat"
        out_cheat_path = None
        ips_path = sys.argv[1]
        if len(sys.argv) > 2:
            cheat_name = sys.argv[2]
        if len(sys.argv) > 3:
            out_cheat_path = sys.argv[3]
        ips2cheat(ips_path, cheat_name, out_cheat_path)